// datastruct_and_algorithm_03.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//第三阶段
// 四种算法思想：贪心、分治、回溯、动态规划
// 跳表
// 拓扑排序、Dijkstra算法、A* 算法
// B + 树
// 位图
//

//
//贪心算法
// 
//背包问题
// 一个容纳100kg的背包，有无五种物品，每种物品总量和总价值不同
// 物品1  100kg   100元
// 物品2  30kg    90元
// 物品3  60kg    120元
// 物品4  20kg    80元
// 物品5  50kg    75元
// 怎样选择，让背包所装物品总价最高
// 当然是 20kg 4 + 30kg 2 + 50kg 3
// 本质上是贪心算法
// 
//分析
// 针对一组数据，定义限制值和期望值，从中选取数据，在限制条件下期望值最高；这类问题考虑贪心算法
// 每次选择当前情况下，对限制值同等贡献量情况下，最期望值贡献量最大的数据
// 举例验证，看贪心产生的结果是否最优
// （并不总能给出最优解，某些问题中，局部最优选择会影响之后的选择，就无法获得全局最优了）
// 
//例
// 分糖 m个糖，n个孩子，m < n
// 每个糖大小不等，大小为s1，s2 ... sm
// 每个孩子对糖大小有要求g1，g2 ... gn
// 只有糖大小大于孩子要求时，才能满足孩子
// 如何分配，满足尽可能多的孩子
// 限制为糖果数m，对于期望值贡献，只要满足一个孩子，贡献值就是相同的，所以无所谓满足更大需求的孩子
// 每次从剩下的孩子中，找出需求最小的，然后发给他剩余糖果中最小能满足他的糖，最终就是最多的方案
// 
// 钱币找零 假设有1、2、5、10、20、50、100面额的纸币，要支付K元，最少需要多少张纸币
// 每次都先用最大面额，超出或不够的部分再选小一点面额的，循环，直到累加到K
// 因为，各面值贡献的张数期望值都是一样的（一张），所以希望每张多贡献一些金额数量
// 
// 区间覆盖 有n个区间，区间为[s1,e1]...[sn,en]，选出一部分区间（区间要求不相交），最多能选多少个区间
// 先计算出左端点最小和右端点最大，也就是区间最大范围 [smin,emax]
// 每次选择中，左端点选未重合的，右端点选尽量小的
// 
//应用
//一个1000字符的文件，存储需要8000bit，有没有更节约的存储方式
// 
// 方法一
// 统计字符，例如发现只有a,b,c,d,e,f六种不同字符，则3bit数可以覆盖所有字符的表示
// 则可以使用3000bit存储完这个文件
// 
// 霍夫曼编码
// 除了统计字符范围，还会统计字符出现频率
// 并依据贪心算法，将频率高的字符用更短的编码，且要求各个字符的编码不会出现某编码是另一个编码前缀的情况（防止解压复杂）
// 例如 出现频率  编码      总占位
// a    450       1         450
// b    350       01        700
// c    90        001       270
// d    60        0001      240
// e    30        00001     150
// f    20        00000     100
// 每次读取时，按最长能解读的二进制串解压（五位，碰到1或全0结束），则原本8000bit的数据只需要1910bit
// 而获取编码的方式，需要根据频率建立优先级队列，在树形结构中，将左权标为0，右权标为1，到每个字符的路径则是编码
// 
//非负整数a中，移除k个数字，让剩下的最小
// 从左到右，比较相邻两位，左边大时，移除左边，否则用右边与下一个相邻数比较，直到移除k个
// 如果一趟操作下来删掉的不足k，则返回第一个再做一次
// 实现时，可用栈，高位开始入栈，大于栈顶直接入栈
// 下个数若小于栈顶，则弹出栈顶直到栈顶元素小于入栈元素（或栈空）同时k-1
// 直到k为0
// 
//窗口服务中，n个人在等，只有一个窗口，每个人被服务时间长度不同，如何安排
// 最小服务时间优先
// 可以建立小顶堆，每次服务堆顶的人
//

int main()
{
    std::cout << "Hello World!\n";
}
