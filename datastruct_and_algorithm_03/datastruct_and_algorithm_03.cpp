// datastruct_and_algorithm_03.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//第三阶段
// 四种算法思想：贪心、分治、回溯、动态规划
// 跳表
// 拓扑排序、Dijkstra算法、A* 算法
// B + 树
// 位图
//

//
//贪心算法
// 
//背包问题
// 一个容纳100kg的背包，有无五种物品，每种物品总量和总价值不同
// 物品1  100kg   100元
// 物品2  30kg    90元
// 物品3  60kg    120元
// 物品4  20kg    80元
// 物品5  50kg    75元
// 怎样选择，让背包所装物品总价最高
// 当然是 20kg 4 + 30kg 2 + 50kg 3
// 本质上是贪心算法
// 
//分析
// 针对一组数据，定义限制值和期望值，从中选取数据，在限制条件下期望值最高；这类问题考虑贪心算法
// 每次选择当前情况下，对限制值同等贡献量情况下，最期望值贡献量最大的数据
// 举例验证，看贪心产生的结果是否最优
// （并不总能给出最优解，某些问题中，局部最优选择会影响之后的选择，就无法获得全局最优了）
// 
//例
// 分糖 m个糖，n个孩子，m < n
// 每个糖大小不等，大小为s1，s2 ... sm
// 每个孩子对糖大小有要求g1，g2 ... gn
// 只有糖大小大于孩子要求时，才能满足孩子
// 如何分配，满足尽可能多的孩子
// 限制为糖果数m，对于期望值贡献，只要满足一个孩子，贡献值就是相同的，所以无所谓满足更大需求的孩子
// 每次从剩下的孩子中，找出需求最小的，然后发给他剩余糖果中最小能满足他的糖，最终就是最多的方案
// 
// 钱币找零 假设有1、2、5、10、20、50、100面额的纸币，要支付K元，最少需要多少张纸币
// 每次都先用最大面额，超出或不够的部分再选小一点面额的，循环，直到累加到K
// 因为，各面值贡献的张数期望值都是一样的（一张），所以希望每张多贡献一些金额数量
// 
// 区间覆盖 有n个区间，区间为[s1,e1]...[sn,en]，选出一部分区间（区间要求不相交），最多能选多少个区间
// 先计算出左端点最小和右端点最大，也就是区间最大范围 [smin,emax]
// 每次选择中，左端点选未重合的，右端点选尽量小的
//

int main()
{
    std::cout << "Hello World!\n";
}
