// datastruct_and_algorithm_02.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//第二阶段
// 散列表
// 二叉树
// 堆和堆排序
// BF / RK字符串匹配算法
// Trie树
// 图的表示
// 深度广度优先搜索
// 

//
//散列表
// 
//问题引入：word拼写检查功能
// 
//散列思想
// 散列表利用的是数组支持按下标随机访问数据的特性（时间复杂度O(1)）
// 通过散列函数，把元素键值映射为下标，然后将数据存储在数组对应的下标
// 查询时，同样从散列函数，将键值转为下标，从对应数组下标位置取数据
// 
//散列函数
// 三个基本需求
// 计算的散列值是一个非负整数（要作为下标）
// 当key1与key2相等，hash(key1)==hash(key2) （准确查询）
// 键值不相等，哈希值也不相等
// 
// 前两个基本需求很好理解，也比较容易实现
// 但第三点几乎不可能
// 
//散列冲突
// 再好的散列函数也无法避免散列冲突，要设计一些解决方案
// 
// 开放寻址
// 如果出现散列冲突，就重新探测一个空闲位置
// 线性探测
// 如果某个数据经过散列后存储位置已经被占用，则从当前位置开始找，看是否有空闲，直到找到
// 二次探测
// 是线性探测的改进，每次探测的步长从1也就是hash(key)+n变为hash(key)+n^2
// 双重散列
// 用一组散列函数，如果第一个散列函数计算的位置被占用则再用第二个，直到找到空闲
// 综合看
// 开放寻址这样的方法，当空闲位置不多时，散列冲突概率会提高
// 为了保证效率，需要保证表内有一定比例的空闲槽位
// 
// 链表法
// 散列表中的每个元素不再直接是元素数据，而是一个桶，对应一个链表，所有散列值相同的元素放在同一个槽位的链表中
// 
//问题解决：
// 常用英文单词存储在一个散列表中，占的内存根据单词数量也只占几M到几十M
// 用户输入单词后，去散列表中查找，找到则拼写正确，反之给提示可能错误
// 
//思考
// 10w条url数据，根据访问次数排序
//  先利用散列表统计次数，再看次数统计的最大值是否大于url记录数，不大于则直接桶排序，超过10w很多则可以快排
// 两个10w条字符串的数组，快速找出两个数组中相同的字符串
//  以其中一个数组构建散列表，再遍历另一个数组在散列表中查找
// 
// 
//工业级散列表
// 
//问题引入：散列表的效率受很多设计因素影响
// 极端情况下，恶意攻击者可以构造数据，使所有数据经过散列后都到同一个槽中（散列表碰撞攻击）
// 这样的话散列表就退化成了链表，查询复杂度从O(1)退化到O(n)
// 如何设计对应各种异常的散列表？（抵抗碰撞，提高性能）
// 
//散列函数设计
// 首先，散列函数本身不能过于复杂，否则时间都消耗在了hash过程中
// 其次，生成的值尽可能随机并均匀的分布
// 例：word拼写检查中，可以将单词每个字母ascii码进位相加，再跟散列表大小取余取模等
// 
// 针对装载因子
// 当空余槽位太少，或空间不够时，与数组一样需要动态扩容
// 动态扩容后，由于散列函数可能涉及到数组空间作为计算参数，则在数据搬移时，每个数据也都需要按照加入散列表的规则重新放入
// 此时的时间复杂度
// 由于搬移数据，为O(n)，但并不是每次插入都需要扩容，所以分摊计算；又由于最好的插入情况为O(1)，所以最终，带动态扩容情况的插入依然复杂度为O(1)
// 
// 避免低效扩容
// 当数据量过大时，扩容一次的效率会很低，因为涉及到大量数据的重新计算入表，导致个别插入操作缓慢
// 可以将扩容操作穿插在插入操作中，分批完成
// 也就是 渐进式rehash
// 扩容时不直接搬移数据
// 同时使用两个哈希表，ht0和ht1
// 查找从两个表中各自进行一次，删除和更新都是；只有新增操作是只放入ht1，这样下来，ht0只减不增，并随着rehash进行，最终ht0变为空表
// 
// 冲突解决方案的选择
// 数据量小时，可以使用开放寻址
// 对于链表法，可以将简单的链表改造为跳表、红黑树等高效结构，这样就算所有数据都分配到一个槽，退化后查找时间也就是O(logn)，有效避免碰撞攻击
// 
//JAVA的HashMap设计
// 初始大小 可设置，默认16
// 装载因子 默认0.75，当元素个数超过0.75*capacity，则扩容为两倍
// 散列冲突 使用链表法，在1.8之后，当链表长度太长（默认8）时，链表转为红黑树，元素少（6）时再转回来（维护平衡的性能与元素个数遍历的性能衡量）
// 散列函数 使用对象自己的hashcode函数计算一个值，再统一处理一次 (h^(h>>>16))&(capicity-1)
// 
// 
//散列表和链表
// 
//从之前的LRU缓存淘汰算法开始
// 一个按访问时间从大到小有序排列的链表，当缓存空间不够时，将链表头部节点删除
// 取某数据时，缓存中没有，则将数据放入链表尾部，如果有，直接使用，并将其移动到链表尾部
// 单纯使用链表实现的LRU，时间复杂度为O(n)
// 
// 缓存系统中的几个操作，添加、删除、查找
// 而每个操作其实都涉及查找，可以结合散列表使用
// 以双链表存储数据，每个节点新增一个字段hnext作为散列表每个槽位中链表的后继指针
// 也就是每个节点存在于两条链中，双链表用于处理缓存的淘汰时间，每个槽位的拉链用于快速查找节点位置
//

int main()
{
    std::cout << "Hello World!\n";
}
