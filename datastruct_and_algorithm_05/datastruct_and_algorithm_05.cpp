// datastruct_and_algorithm_05.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//实战和练习
//

//
//Redis常用数据类型的结构
// 
//非关系型数据库
// 只包含键、值两部分，通过键查询值（mysql关系型数据库包含多个字段，通过sql语句查询）
// 主要作为内存数据库使用（也支持存在硬盘）
// 键的类型是字符串
// 值的类型有多种，常用：字符串、列表、字典、集合、有序集合
// 
//列表
// 存储一组数据，实现方式有两种
// 压缩列表 和 双向循环链表
// 
// 数据量小时，可以使用压缩列表
//  单个数据小于64字节
//  列表中数据个数小于512个
// 是redis自己设计的数据存储结构
// 通过连续内存空间存储数据，类似数组但可以存储大小不同的数据
// [data_num][data1_len][data1][data2_len][data2]...
// 例 3-2-ab-5-abcde-3-abc...
// 若用普通数组，每个字符串就都需要5字节，有一定的内存浪费，并且不支持不同类型
// 
// 数据量大，需要用双向循环链表
typedef struct redis_listnode
{
    struct redis_listnode* prev;
    struct redis_listnode* next;
    void* value;
} redis_listNode;
typedef struct redis_list
{
    redis_listNode* head;//记录头尾、长度等信息，使用更方便些
    redis_listNode* tail;
    unsigned long len;
    //...
}redis_List;
// 
//字典
// 每个数据又包含键值两部分
// 也是两种实现方式，压缩列表、散列表
// 
// 压缩列表实现和限制条件与列表相同
// 
// 数据量大使用散列表
// 哈希函数用的是MurmurHash
// https://github.com/aappleby/smhasher/
// 装载因子大于1时，扩容2倍；小于0.1时，缩容
// 
//集合
// 存储一组不重复数据
// 
// 满足条件
//  存储数据是整数
//  元素个数不超过512
// 采取有序数组
// 
// 否则使用散列表
// 
//有序集合
// 除了之前说的跳表，数据量小也可以使用压缩列表
// 
//持久化
// 其实就是存储到磁盘
// 当机器断电，存储数据不会丢失，重启后重新读取到内存即可
// 将数据存储到硬盘时，主要两种思路
// 
// 清除原有存储结构
// 只讲数据存储到磁盘
// 还原时，再组织成原结构（redis就是这种）
// 但例如散列表这样的数据读取时，相当于每个数据需要重新计算hash，数据量大时，这个过程耗时很高
// 
// 另一种是保留原有存储格式
// 还是用散列表举例，可以将大小、散列到的槽的编号都同时保存
// 读取时，直接还原，不需要重新计算
// 
//总结
// 压缩列表、有序数组、链表、散列表、跳表
// redis就是这些常用数据结构的封装
// 
// 较小数据量下，采用压缩列表，减小内存占用，并且cpu友好，有利于使用l2缓存，是升级版数组
// 但不支持随机访问（元素大小不一样），需要遍历，且需要连续空间，所以
// 数据量大用散列表或其他数据结构
// 
//思考
// 二叉树存储
// 填充叶子节点形成完全二叉树，然后以数组形式存储到硬盘
// （还有一个结合中序和前序遍历存储，然后根据两种顺序还原唯一树结构，但是不是需要两倍的空间）
//

int main()
{
    std::cout << "Hello World!\n";
}
