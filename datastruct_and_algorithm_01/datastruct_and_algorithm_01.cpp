// datastruct_and_algorithm_01.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//极客时间——数据结构与算法之美
//

//
//第一阶段
// 复杂度
// 数组、栈、队列
// 链表
// 递归
// 排序
// 二分查找
//

//
//数组
//

//
//大部分语言数组都是从0开始的（lua从1开始）
// arr[i]_addr = base_addr + i * data_type_size
// 如果从1开始，寻址公式则成为
// arr[i]_addr = base_addr + (i - 1) * data_type_size
// 对于CPU来说，多做一次减法指令
// （不过，更多的应该还是历史问题；毕竟C语言开始这已经是共识和习惯）
//

//
//数组随机访问的复杂度为O(1)，而不能说是查找
// 只是更适合查找，不知道索引的情况，排好序的数组二分法查找O(logn)
// 
//插入删除有大量数据搬移
// 也都有方法优化
// 例如删除，在数组有剩余空间的情况下，删除的数据只是标记为删除，并不进行真正的数据搬移
// 没有空间时，再统一进行一次删除操作（类似JVM垃圾回收算法、MySQL的B+树中的删除、硬盘上的数据删除；都是“假删除”）
// 

//
//越界
void
test_out_of_range()
{
	int i = 0;
	int arr[3] = { 0 };
	for (; i <= 3; ++i)
	{
		arr[i] = 0;
		std::cout << "test_out_of_range()" << std::endl;
	}
}
//数组越界会导致不明确行为，依赖于编译器不同的处理方式
// 大部分高级语言，会直接检测到数据越界异常
// 在C中，只要不是受限内存都是可以自由访问的，所以即使越界也不会报错
// 如果按最早期gcc版本（或者新版本编译器关闭栈溢出保护）
// 例如， gcc -fno-stack-protector test.c
/*

linux下gdb调试，查看各变量地址，发现数组溢出位置与i刚好一致，i被重置为0，无限循环
(gdb) p &i
$4 = (int *) 0x7fffffffdc5c
(gdb) p &arr[0]
$5 = (int *) 0x7fffffffdc50
(gdb) p &arr[1]
$6 = (int *) 0x7fffffffdc54
(gdb) p &arr[2]
$7 = (int *) 0x7fffffffdc58
(gdb) p &arr[3]
$8 = (int *) 0x7fffffffdc5c
(gdb)

*/
// 很多病毒就是利用了溢出漏洞来攻击系统
//

//
//数组替代品，自动扩容的容器
// C++ vector等
//


//
//链表
//

//
//经典场景 LRU缓存淘汰算法
// 缓存在软硬件应用很多
//	CPU缓存，有寄存器缓存，一级、二级、三级缓存，CPU到内存，内存到硬盘中间都有Cache
//	数据库缓存，软件缓存，例如redis作为mysql缓存
//	浏览器缓存，页缓存（前进后退）、内存缓存（页面派生资源）、磁盘缓存（cookie）
// 常见淘汰策略
//	LRU：least recent used 最近最少使用
//	LFU：least frequent used 最少使用
//	FIFO：first in,first out 先进先出
//

//
//底层结构
// 与数组的连续内存空间不同，链表不需要连续内存空间，通过指针将一堆零散内存块串联起来
// 
//最常见
// 单链表、双链表、循环链表
//

//
//单链表
// 每个链表节点除了存储数据，还需记录下一个节点地址，一般称为后继节点
// 第一个节点称为头节点，最后一个节点是尾节点
// 头节点记录链表基地址，由它可以遍历到整条链
// 尾节点的后继节点指向空地址NULL，防止next称为野指针，出现不明确行为
// 
//支持操作
// 数据查找、插入、删除
// 链表插入或删除只需要考虑相邻节点指针变化，时间复杂度O(1)，没有数组那样的大量搬移操作
// 而访问第k个元素，就需要遍历找到，不如数组通过下标直接定位
//

//
//循环链表
// 特殊单链表，区别在于尾节点指向头节点
// 处理 约瑟夫问题 类场景比较有用
//

//
//双链表
// 支持两个方向，每个节点除了由后继节点指针，还有一个前驱节点指针
// 插入删除等操作比单链表高效，虽然常说单链表是O(1)，但也有先决条件
// 例如删除，可能是删除某值节点，或删除指针指向节点
// 对于先要查找对应值删除的情况，其实复杂度也是O(n)，因为要遍历才能找到值
// 对于删除指定指针指向的节点，删除时需要找到该节点的前驱节点
// 单链表找前驱节点要从头遍历，时间复杂度O(n)，双链表为O(1)
// 所以这种情况，双链表更有优势
// 在某指定节点前面插入节点，也是同理
// 双链表就是典型的空间换时间的思想，当内存充足，可以选择空间复杂度高但时间复杂度相对低的方法
// 
// 缓存也是空间换时间
//

//
//总结，数组和链表
// 数组大小固定的连续空间，扩容时重新分配内存并拷贝；链表是不连续的，天然支持动态扩容
// 数组有下标可以快速随机访问，插入删除需要搬移数据；链表查找指定值需要遍历，插入删除较快（都要考虑场景）
// 
// 如果代码对内存使用比较敏感，还是数组更合适，链表每次都涉及内存的申请释放等操作，造成内存碎片（JAVA中会导致频繁GC）
//

//
//LRU淘汰算法
// 有序单链表，越是尾部的节点是越早访问的，当有新的数据被访问，从链表头开始遍历（反过来用头部的表示待删除也是一样的）
// 如果数据已经被缓存，得到数据对应节点，将其从原来位置删除，再插入头部
// 如果没被缓存，缓存未满则插入头部，如果缓存已满，尾部节点删除，将新数据插入头部
// 
// 其中
// 不管缓存是否满，都需要遍历来访问缓存，时间复杂度O(n)
// 优化可以引入散列表，访问的时间复杂度降为O(1)
//

//
//链表边界
// 链表为空
// 只含一个节点
// 只含两个节点
// 处理的是头节点或尾节点
//

//
//重点操作
// 单链表反转
// 环检测
// 两个有序链表合并
// 删除倒数第n个结点
// 找中间节点
//


//
//栈
//

//
//后进先出
// 
//功能上，数组和链表可代替，但暴露接口太多容易出错
// 
//只涉及一端插入和删除，并需要后进先出，就可以使用栈
//
class ArrayStack
{
public:
	ArrayStack(int n)
		: m_size(n)
	{
		m_arr = new int[n];
	}
	~ArrayStack()
	{
		delete[] m_arr;
		m_arr = nullptr;
	}
public:
	bool push(int item)
	{
		if (m_count == m_size) return false;
		m_arr[m_count++] = item;
		return true;
	}

	int pop()
	{
		if (m_count == 0) return -1;
		int ret = m_arr[m_count - 1];
		--m_count;
		return ret;
	}

private:
	int* m_arr = nullptr;
	int m_count = 0;
	int m_size = 0;
};
//
//空间复杂度O(1)
// 并非大小为n的数组就是空间复杂度O(n)，n个空间是必须的，无法省掉，空间复杂度指的是额外的空间
//时间复杂度O(1)
// 不管顺序栈还是链式栈，出入栈操作都只涉及栈顶个别数据操作
//

//
//支持动态扩容的顺序栈
// 只要底层依赖一个动态扩容的数组就可以实现了
// 
//时间复杂度
// 出栈仍然是O(1)
// 入栈最好情况也是O(1)，空间不够时，重新申请内存和数据偏移，最坏情况O(n)
// 初始n个大小的栈，n次入栈后，涉及到扩容，扩容后n次数据搬移，n次入栈，均摊后，每个入栈对应一次搬移和一次不涉及扩容的push
// 所以时间复杂度为O(1)，一般来说，均摊时间复杂度都是最好情况时间复杂度
//

//
//栈应用
// 
// 函数调用
// 函数在内存中以栈的结构使用
// 进入一个函数，参数压栈，若有临时变量，继续压栈
// 调用结束则根据栈帧出栈
// 
// 表达式计算
// 1+2+3
// 一个表达式，两个栈存储
// 数字直接压入一个栈，表达式压栈要判断一下与栈顶运算符的优先级
// 若优先级更高，则入栈；若优先级想同或更低，则先把两个栈内结果运算完，再继续之前的逻辑
// 
// 括号匹配
// 
// 浏览器前进后退
// 两个栈分别存放前进后退的页面
//


//
//队列
//

//
//后进先出
// 
//数组和链表都能实现
//
class ArrayQueue
{
public:
	ArrayQueue(int cap)
		:m_size(cap)
	{
		m_arr = new int[cap];
	}
	~ArrayQueue()
	{
		delete[] m_arr;
		m_arr = nullptr;
	}
public:
	bool enqueue(int num)
	{
		if ((m_tail + 1) % m_size == m_head) return false;
		m_arr[m_tail] = num;
		m_tail = (m_tail + 1) % m_size;
		return true;
	}
	int dequeue()
	{
		if (m_head == m_tail) return -1;
		int ret = m_arr[m_head];
		m_head = (m_head + 1) % m_size;
		return ret;
	}

private:
	int* m_arr = nullptr;
	int m_size = 0;
	int m_head = 0;
	int m_tail = 0;
};
//
//


//
//递归
//

//
//最简雏形
// f(n) = f(n-1) + 1;
// f(1) = 1;
//

//
//递归的条件
// 一个问题可以分解为几个子问题
// 问题与分解后的子问题除了数据规模不同，求解思路相同
// 存在递归终止条件
//

//
//关键
// 找到规律，分解问题
// 找出终止条件
// 
//警惕
// 栈溢出，层次很深时，函数一直压栈
// 重复计算
// 
//转换
// 递归  ->  迭代
// 规律      循环
// 终止		 初始
//


//
//排序
// O(n^2)	冒泡、插入、选择	基于比较
// O(nlogn) 快排、归并			基于比较
// O(n)		桶、计数、基数		不基于比较
//

//
//排序算法分析
// 最好、最坏、平均时间复杂度
// 时间复杂度系数、常数、低阶
// 比较次数和移动次数
// 
//内存消耗
// 原地排序，空间O(1)，冒泡、插入、选择都是
// 
//稳定性
// 如果待排序序列中，相同元素的原有顺序没变，则是稳定的
// 如 2 3 4 3 到 2 3 3 4 ，若两个3顺序变化了，则不稳定
// 稳定性的应用
// 按时间排序的订单列表，希望按金额排序，但排序后相同金额的项，希望还是按时间排序，这就需要排序的稳定性
//

//
//冒泡排序
// 只操作相邻的两个数据，每次操作比较两元素，是否满足关系要求，不满足则交换
// 多趟比较后，整个序列有序（其中某趟不含交换的话，后续的都可以省略了）
// 
void
bubble_sort(int* arr, size_t n)
{
	if (n <= 1) return;

	for (int i = 0; i < n; ++i)
	{
		bool flag = false;

		for (int j = 0; j < n - 1 - i; ++j)
		{
			if (arr[j] > arr[j + 1])
			{
				flag = true;
				int temp = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = temp;
			}
		}

		if (!flag)
			break;
	}
}
// 原地排序、稳定排序
// 时间复杂度 最好一趟排序O(n)，最坏n趟O(n^2)
// 平均O(n^2)
//

//
//插入排序
// 将数组分为已排序区间和未排序区间
// 初始区间为一个元素，取未排序的元素，在已排序区间找合适的位置插入
// 直到未排序区间为空
// 
void
insert_sort(int* arr, size_t n)
{
	if (n <= 1) return;

	for (int i = 1; i < n; ++i)
	{
		int value = arr[i];
		int j = i - 1;
		for (; j >= 0; --j)
		{
			if (arr[j] > value)
				arr[j + 1] = arr[j];
			else
				break;
		}
		arr[j + 1] = value;
	}
}
// 原地排序、稳定排序
// 时间复杂度 最好O(n)，最坏O(n^2)，平均O(n^2)
//

//
//选择排序
// 与插入排序一样是两个区间
// 每次从未排序区间找到最小的元素，放到已排序的末尾
//
void
select_sort(int* arr, size_t n)
{
	if (n <= 1) return;

	for (int i = 0; i < n; ++i)
	{
		int min = i;

		for (int j = i; j < n; ++j)
			if (arr[min] > arr[j])
				min = j;

		int temp = arr[i];
		arr[i] = arr[min];
		arr[min] = temp;
	}
}
//
// 原地排序、不稳定排序
// 时间复杂度 最好最坏都是O(n^2)
//

//
//冒泡、插入、选择比较
// 选择排序不稳定，时间复杂度又怎么都是O(n^2)，逊色一些
// 冒泡和插入
// 不管怎么优化，冒泡的复杂程度依赖于元素交换次数，插入排序复杂度取决于元素移动次数
// 但代码中，冒泡的交换操作是三个赋值操作，而插入排序的移动只有一个赋值操作
// 所以，时间复杂度虽然一样，首选插入
//

//
//归并排序
// 分治思想
// 把数组从中间分成前后两部分，分别排序
// 再把两部分合并
// 
// 时间复杂度永远是O(nlogn)
// 但合并数组过程需要借助额外的数组进行，所以不是原地排序，空间复杂度O(n)
//

//
//快速排序
// 从区间中选择一个点，一般是头或者尾处，作为区分点pivot
// 遍历区间中数据，小于pivot的放到左边，大于的放在右边
// 排序后pivot左边都是小于分界点的，右边都是大的
// 再把开头到分界点前和分界点后到尾分别递归做同样的处理
// 
int
quick_sort_partition(int* arr, int p, int r)
{
	int pivot = arr[r];
	int ret = p;
	for (int i = p; i < r; ++i)
	{
		if (arr[i] < pivot)
		{
			int temp = arr[ret];
			arr[ret] = arr[i];
			arr[i] = temp;
			++ret;
		}
	}
	int temp = arr[ret];
	arr[ret] = arr[r];
	arr[r] = temp;
	return ret;
}
void
quick_sort_impl(int* arr, int p, int r)
{
	if (p >= r) return;

	int pivot = quick_sort_partition(arr, p, r);
	quick_sort_impl(arr, p, pivot - 1);
	quick_sort_impl(arr, pivot + 1, r);
}
void
quick_sort(int* arr, size_t n)
{
	quick_sort_impl(arr, 0, n - 1);
}
// 
// 原地排序、不稳定排序
// 时间复杂度 最好O(nlogn)，最坏O(n^2)，平均O(nlogn)
//

//
//归并和快排
// 都用分治思想
// 归并是先分解再处理，快排是先处理再分解
// 归并是稳定的但需要额外的空间，快排不稳定、时间可能退化到O(n^2)
// 但快排平均还是O(nlogn)，节约空间一般更重要些，所以使用较多
//

//
//桶排序
// 场景：根据年龄给100万用户排序
// 除了归并，快排这种O(nlogn)时间复杂度的方法
// 还可以使用桶排序，时间复杂度只有O(n)
// 
// 桶排序核心思想是将要排序的数据分到几个有序的桶，每个桶里的数据单独进行排序
// 各自排序后，再把每个桶的数据按顺序取出
// 
// 复杂度计算
// n个数据，分到m个桶，每个桶里k = n/m个元素
// 每个桶假设使用快排，时间复杂度O(k*logk)，再乘以桶数 O(m*k*logk) = O(m*n/mlog(n/m)) = O(n*log(n/m))
// 当m无限接近于n，则复杂度接近O(n)
// 
// 桶排序比较适合用在外部排序，数据量比较大，内存有限，无法全部加载到内存
// 
// 例：
// 有10G订单数据，希望按金额排序，内存有限只有几百MB，不能一次性加载
// 思路：
// 先扫描一遍文件，查看订单金额所处范围，比如最小1，最大10w
// 划分到100个桶里，第一个桶存储1到1000，依此类推，每个桶对应一个文件，并按金额顺序标号
// 理想状况下，订单较平均的划到这些文件中，则各自占100MB，接着把每个文件加载到内存中进行快排
// 所有文件排序完毕后，按文件编号从小到达读取每个小文件，并写入一个文件中
// 但也是理想状态
// 如果某个区间的订单极多超过内存限制，则把不能处理的文件再按同样的思路二级处理，例如编号1的文件1~1000金额再分1~100...等
//

//
//计数排序
// 可以算是桶排序的特殊情况
// 若所处范围并不大，如都是1~100，直接按范围值划分成100个桶
// 这也就是上面说的O(n*log(n/m))中m无限接近于n的情况
// 这样每个桶内数据都一样，可以节约桶内排序的时间
// 
// 例
// 几十万的考生，按总分排名，总分几百分
// 直接分成几百个桶，分数相同的考生划到一个桶
// 
// 与桶排序的区分
// 思想类似，只是桶大小粒度不一样，计数的含义是什么？
// 假设 数组 A[8] = {2,5,3,0,2,3,0,3} 确定数值范围0~5
// 先扫描一遍，用 C[6] = {2,0,2,3,0,1} 表示每个数值的个数统计
// 接着，将计数的数组做处理 C[6] = {2,2,4,7,7,8} 每个索引下存储的是小于等于其所代表数值的元素个数
// 继续，从后到前，扫描 A[8] , 从数值3开始，在C[6]中，代表3的为7，找一个新数组R[8]存放排序后的数据
// 扫描到的3在整个数据中，小于等于3的总共7个，则可以放入R的第七个位置 R[8] = {0,0,0,0,0,0,3,0}
// 此时这个数据已经处理完成，更新计数数组 C[6] = {2,2,4,6,7,8} 代表这次之后，小于等于3的数据只有6个了
// 继续扫描，值0，对应计数中的2，放入新数组第二个位置 R = {0,0,0,0,0,0,3,0} 计数数组 C = {1,2,4,6,7,8}
// 以此类推处理完所有数据
// 
void
count_sort(int* arr, size_t n)
{
	if (n <= 1) return;				//边界，无需排序的情况

	int max = arr[0];				//第一次扫描，确认数值范围
	for (int i = 1; i < n; ++i)
		if (arr[i] > max)
			max = arr[i];

	int* count = new int[max + 1];	//计数数组
	memset(count, 0, max + 1);
	for (int i = 0; i < n; ++i)
		++count[arr[i]];			//统计各元素个数

	for (int i = 1; i <= max; ++i)	//累加成小于等于每个元素个数的计数
		count[i] = count[i] + count[i - 1];

	int* temp = new int[n];			//缓存结果的辅助数组
	memset(temp, 0, n);

	//根据原数组和计数数组，将数据按序放到辅助数组
	for (int i = n - 1; i >= 0; --i)
	{
		int index = count[arr[i]] - 1;
		temp[index] = arr[i];
		--count[arr[i]];
	}

	//结果拷贝回原数组
	for (int i = 0; i < n; ++i)
		arr[i] = temp[i];

	//回收资源
	delete[] count;
	count = nullptr;
	delete[] temp;
	temp = nullptr;
}
// 
// 变化应用
// 一般这个方法适用于非负整数，因为数值要作为索引范围
// 所以，如果是小数点后一位，可以所有数据乘10处理后再进行
// 如果是负数，则先加上负数范围的数
// 宗旨就是先转换为非负整数，处理完可以再恢复
//

//
//基数排序
// 场景：10万手机号码，从小到达排序
// 快排几乎可以解决一切，时间复杂度O(nlogn)
// 更快的桶和计数排序就不再合适了，因为手机号是11位，范围较大
// 
// 基数排序思路
// 首先，手机号码中，AB两个号码从头开始比较，从某一位开始，如果A大于B，那么后续就不用比了，A一定大于B
// 所以，从头开始，按第一位排序，所有都是1，理论上可以直接略过，再按第二位排序，一般有3，5，7，8，9等
// 以此类推，总共排序11趟，每次只比较同位的数值
// 每趟的排序中可以用桶或者计数，时间复杂度O(n)，而总共需要k次，复杂度为O(k*n)
// 手机号例子中，k为11，并不大，所以复杂度也是接近O(n)的
// 
// 另外，如果不都是手机号这种位数一致的数据，也可以通过前面补0，并从最后一位向前进行排序的方式
//

//
//排序优化
// 排序对比		时间复杂度		稳定		原地
// 冒泡			n^2				是			是
// 插入			n^2				是			是
// 选择			n^2				否			是
// 快排			nlogn			否			是
// 桶、计、基	n				是			否
// 
// 其中，线性排序桶、计、基使用范围不大，只适合特殊场景
// 小规模排序，为了实现简单，n^2复杂度的算法也是可以用的
// 如果想用一个兼顾任意规模和数据类型的算法实现一个通用排序函数，一般都是快速排序（c中，JAVA用的堆排序）
// 
// 虽然快排在极端情况下时间复杂度n^2
// 归并在任何时候复杂度nlogn，但空间复杂度翻倍的劣势还是让快排应用更多
// 所以，为了解决快排的极端情况，需要进行优化
// 宗旨就是，选择区分点的时候，让两边的数据尽量均衡（之前的例子都是直接选择第一或最后一个）
// 
// 快排优化方案
//	三数取中 将数组从首尾中间分别取一个数，取中间值（不一定是3个，也可能更多）
//	随机取分界点 概率的角度来说，出现每次都选择很差的分界点的情况比较少
// 另外，注意递归过深问题，限制深度或堆上模拟调用栈
// 
// 实际中
// Glibc的qsort()为例，其实是综合的算法
// 在数据较小时，优先使用了归并排序，数据较大才改用快排
// 在数据量极小（如4个以下）时，甚至是直接用的插入排序
//

//
//二分查找
// 场景 1000万整型数据，每个数据8字节，在100MB内存空间中设计数据结构和算法，快速判断某数值是否在这些数据中
// 
// 遍历查找效率很低，可以使用二分查找（思想是指数放大速度极快，反过来，二分相当于指数缩小，所以不管数量级多大，指数时间的复杂度也很低）
// 时间复杂度，根据被查找区间 n,n/2,n/4,...,n/2^k，=> O(logn)
// 
// 简单实现
int
binary_search(int* arr, int n, int value)
{
	int low = 0, high = n - 1;

	while (low <= high)
	{
		int mid = low + (high - low) >> 1;//防止越界，并用位移操作代替除法
		if (arr[mid] == value)
			return mid;
		else if (arr[mid] > value)
			high = mid - 1;
		else
			low = mid + 1;
		
	}

	return -1;
}
// 递归实现
int 
binary_search_impl(int* arr, int low, int high, int value)
{
	if (low > high) return -1;	//没找到

	int mid = low + (high - low) >> 1;
	if (arr[mid] == value)
		return mid;
	else if (arr[mid] > value)
		return binary_search_impl(arr, low, mid - 1, value);
	else
		return binary_search_impl(arr, mid + 1, high, value);
}
int
_binary_search(int* arr, int n, int value)
{
	binary_search_impl(arr, 0, n - 1, value);
}
// 
// 局限
// 依赖顺序表结构，也就是数组
// 数据需要有序
// 数据量小时没必要，遍历即可
// 数量太大也不合适，几百兆还好，如果1GB的数据，在内存中申请1GB的连续内存是很难的
// 刚才的例子中，又是只针对没有重复元素的情况
// 
//例：
// 通过百度搜索IP，显示IP信息。这个功能的实现
// 维护一个很大的IP库，库中包括IP及其对应信息
// 涉及到某个IP的查询，搜索这个IP落在哪个IP段，对应哪个归属地等
// 这应用了二分查找的变形
// 
// 常见变形（主要针对有多个查找值的情况）
//	查找第一个等于给定值的元素
//	查找最后一个等于给定值的元素
//	查找第一个大于等于给定值的元素
//	查找最后一个小于等于给定值的元素
// 
// 针对查找第一个等于给定值的元素
int
binary_search_first(int* arr, size_t n, int value)
{
	int low = 0, high = n - 1;

	int mid = low + (high - low) >> 1;
	while (low <= high)
	{
		if (arr[mid] > value)
			high = mid - 1;
		else if (arr[mid] < value)
			low = mid + 1;
		//前面逻辑都一样，额外处理下第一次找到值后的情况
		else
		{
			if ((mid == 0) || arr[mid - 1] != value)
				return mid;//找到的是第一个元素，或者前面没有相等的元素了，那一定就是第一个了
			else
				high = mid - 1;//前面还有，则从当前值往前继续找，往后则不用考虑，因为是找第一个出现的

			//处理查找最后一个的情况，则是反过来，先判断是否找到的是末尾或者当前位置后面还有没有符合条件的元素，之后往后找
		}
	}
}
// 
// 针对大于等于、小于等于的，更简洁些，相当于把==和前面大小比较的其中一个情况合并了
int bsearch(int* a, size_t n, int value) {
	int low = 0;
	int high = n - 1;
	while (low <= high) {
		int mid = low + ((high - low) >> 1);
		if (a[mid] >= value) {
			if ((mid == 0) || (a[mid - 1] < value)) return mid;
			else high = mid - 1;
		}
		else {
			low = mid + 1;
		}
	}
	return -1;
}
// 
//

int main()
{
	test_out_of_range();
}
