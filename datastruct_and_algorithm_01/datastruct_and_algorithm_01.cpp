// datastruct_and_algorithm_01.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//极客时间——数据结构与算法之美
//

//
//数组
//

//
//大部分语言数组都是从0开始的（lua从1开始）
// arr[i]_addr = base_addr + i * data_type_size
// 如果从1开始，寻址公式则成为
// arr[i]_addr = base_addr + (i - 1) * data_type_size
// 对于CPU来说，多做一次减法指令
// （不过，更多的应该还是历史问题；毕竟C语言开始这已经是共识和习惯）
//

//
//数组随机访问的复杂度为O(1)，而不能说是查找
// 只是更适合查找，不知道索引的情况，排好序的数组二分法查找O(logn)
// 
//插入删除有大量数据搬移
// 也都有方法优化
// 例如删除，在数组有剩余空间的情况下，删除的数据只是标记为删除，并不进行真正的数据搬移
// 没有空间时，再统一进行一次删除操作（类似JVM垃圾回收算法、MySQL的B+树中的删除、硬盘上的数据删除；都是“假删除”）
// 

//
//越界
void
test_out_of_range()
{
	int i = 0;
	int arr[3] = { 0 };
	for (; i <= 3; ++i)
	{
		arr[i] = 0;
		std::cout << "test_out_of_range()" << std::endl;
	}
}
//数组越界会导致不明确行为，依赖于编译器不同的处理方式
// 大部分高级语言，会直接检测到数据越界异常
// 在C中，只要不是受限内存都是可以自由访问的，所以即使越界也不会报错
// 如果按最早期gcc版本（或者新版本编译器关闭栈溢出保护）
// 例如， gcc -fno-stack-protector test.c
/*

linux下gdb调试，查看各变量地址，发现数组溢出位置与i刚好一致，i被重置为0，无限循环
(gdb) p &i
$4 = (int *) 0x7fffffffdc5c
(gdb) p &arr[0]
$5 = (int *) 0x7fffffffdc50
(gdb) p &arr[1]
$6 = (int *) 0x7fffffffdc54
(gdb) p &arr[2]
$7 = (int *) 0x7fffffffdc58
(gdb) p &arr[3]
$8 = (int *) 0x7fffffffdc5c
(gdb)

*/
// 很多病毒就是利用了溢出漏洞来攻击系统
//

//
//数组替代品，自动扩容的容器
// C++ vector等
//


//
//链表
//

//
//经典场景 LRU缓存淘汰算法
// 缓存在软硬件应用很多
//	CPU缓存，有寄存器缓存，一级、二级、三级缓存，CPU到内存，内存到硬盘中间都有Cache
//	数据库缓存，软件缓存，例如redis作为mysql缓存
//	浏览器缓存，页缓存（前进后退）、内存缓存（页面派生资源）、磁盘缓存（cookie）
// 常见淘汰策略
//	LRU：least recent used 最近最少使用
//	LFU：least frequent used 最少使用
//	FIFO：first in,first out 先进先出
//

//
//底层结构
// 与数组的连续内存空间不同，链表不需要连续内存空间，通过指针将一堆零散内存块串联起来
// 
//最常见
// 单链表、双链表、循环链表
//

//
//单链表
// 每个链表节点除了存储数据，还需记录下一个节点地址，一般称为后继节点
// 第一个节点称为头节点，最后一个节点是尾节点
// 头节点记录链表基地址，由它可以遍历到整条链
// 尾节点的后继节点指向空地址NULL，防止next称为野指针，出现不明确行为
// 
//支持操作
// 数据查找、插入、删除
// 链表插入或删除只需要考虑相邻节点指针变化，时间复杂度O(1)，没有数组那样的大量搬移操作
// 而访问第k个元素，就需要遍历找到，不如数组通过下标直接定位
//

//
//循环链表
// 特殊单链表，区别在于尾节点指向头节点
// 处理 约瑟夫问题 类场景比较有用
//

//
//双链表
// 支持两个方向，每个节点除了由后继节点指针，还有一个前驱节点指针
// 插入删除等操作比单链表高效，虽然常说单链表是O(1)，但也有先决条件
// 例如删除，可能是删除某值节点，或删除指针指向节点
// 对于先要查找对应值删除的情况，其实复杂度也是O(n)，因为要遍历才能找到值
// 对于删除指定指针指向的节点，删除时需要找到该节点的前驱节点
// 单链表找前驱节点要从头遍历，时间复杂度O(n)，双链表为O(1)
// 所以这种情况，双链表更有优势
// 在某指定节点前面插入节点，也是同理
// 双链表就是典型的空间换时间的思想，当内存充足，可以选择空间复杂度高但时间复杂度相对低的方法
// 
// 缓存也是空间换时间
//

//
//总结，数组和链表
// 数组大小固定的连续空间，扩容时重新分配内存并拷贝；链表是不连续的，天然支持动态扩容
// 数组有下标可以快速随机访问，插入删除需要搬移数据；链表查找指定值需要遍历，插入删除较快（都要考虑场景）
// 
// 如果代码对内存使用比较敏感，还是数组更合适，链表每次都涉及内存的申请释放等操作，造成内存碎片（JAVA中会导致频繁GC）
//

//
//LRU淘汰算法
// 有序单链表，越是尾部的节点是越早访问的，当有新的数据被访问，从链表头开始遍历（反过来用头部的表示待删除也是一样的）
// 如果数据已经被缓存，得到数据对应节点，将其从原来位置删除，再插入头部
// 如果没被缓存，缓存未满则插入头部，如果缓存已满，尾部节点删除，将新数据插入头部
// 
// 其中
// 不管缓存是否满，都需要遍历来访问缓存，时间复杂度O(n)
// 优化可以引入散列表，访问的时间复杂度降为O(1)
//

//
//链表边界
// 链表为空
// 只含一个节点
// 只含两个节点
// 处理的是头节点或尾节点
//

//
//重点操作
// 单链表反转
// 环检测
// 两个有序链表合并
// 删除倒数第n个结点
// 找中间节点
//

int main()
{
	test_out_of_range();
}
