// labuladong_note_01.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//学习 labuladong 算法小抄
//


//数据结构的存储方式
// 
//本质只有
// 数组（顺序存储）
// 链表（链式存储）
// 
//队列和栈既可以使用链表也可以用数组
//图的两种表示法中，邻接表是链表、邻接矩阵就是二维数组
//散列表通过hash函数把键映射到一个大数组里
//树，常见用链表实现，有二叉搜索树、AVL树、红黑树、区间树、B树
// 用数组实现就是堆，堆是一个完全二叉树
// 
//数组
// 紧凑连续存储，可以随机访问，通过索引可以快速找到对应元素
// 相对节约空间，但需要扩容的话需要重新分配再将原数据拷贝
// 插入和删除操作每次需要移动其后面所有数据
//链表
// 元素不连续，不存在扩容问题，插入删除也更快
// 无法根据索引进行随机访问
// 需要保存指针，相对消耗更多存储空间
// 
//基本操作
// 遍历访问
// 增删改查
// 
//遍历方式
// 线性 for/while
// 非线性 递归
void traverse(int* arr, size_t len) {
	for (int i = 0; i < len; i++)
	{
		//迭代访问 arr[i]
	}
}
typedef struct _list_node {
	int val;
	list_node* next;
}list_node, * p_list_node;
void traverse2(list_node* head) {
	//递归访问链表
	traverse2(head->next);
}
typedef struct _tree_node {
	int val;
	p_tree_node left, right;
}tree_node, * p_tree_node;
void traverse3(p_tree_node root) {
	//遍历二叉树

	//操作放这就是前序
	traverse3(root->left);
	//操作放这就是中序
	traverse3(root->right);
	//操作放这就是后序
}
//二叉树框架可扩展为N叉树
//图又可以是N叉树的扩展，出现环的话，用一个布尔数组做标记即可
//


//二叉树
// 
//比较容易培养思维，大多数算法技巧本质为树遍历
//动态规划、回溯、分治等涉及到递归的，基本都是树遍历
//


//简单看了之后，觉得这个教程是一个有一定积累之后，比较取巧的一些套路
//不太适合直接去看
//刷题之前，还是需要先把数据结构足够的理解
//之前在educative课程里把各种数据结构的原理都看了一遍，但不够熟练
//还需要找一些其他东西巩固，这个教程也提到了经典的《算法4》
//这就去看
// 
//路线上，教程说的跟自己想的差不多
// 理解基本数据结构。我自己是看了一些网课，经典算法4还没过，准备马上开始
// 刷题，这个顺序可以参考一下
//	先从Explore菜单最下面的Learn开始，包含了数据结构学习和基本算法
//	再看Interview专题或者Problem菜单里开始随意刷
// 
//到这里，先转战《算法4》去了
//


int main()
{
	std::cout << "Hello World!\n";
}
