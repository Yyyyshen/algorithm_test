// datastruct_and_algorithm_04.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>

//
//第四阶段
// BM、KMP、AC自动机
// 红黑树
// 哈希算法
// 高级篇、实战篇
//

//
//BM算法
// 
//字符串匹配算法中，之前了解到
// BF 暴力匹配，用模式串与主串中所有子串匹配
// RK 借助哈希，对每个子串分别求哈希，之后与模式串对比，减少比较时间（由于哈希冲突，再实际比较一次）
// 当RK的哈希冲突严重时，RK退化为BF，时间复杂度O(n*m)
// 需要更高效的算法
// 
//核心思想
// 正常匹配模式串和主串过程中，是模式串再主串中不停的滑动并比较
// abcabd
// abd ->
// BF和RK是找所有子串，相当于每次滑动1位
// 而这样的例子中，用人眼看，可以发现，ab重复，c不重复
// 那么下一次比较应该直接移动到c之后，因为c不再模式串中，在模式串长度内怎么挪动都不会匹配
// 那么代码中，需要定义一些方法衡量这个移动值
// BM就是寻找这种规律，跳过一些一定不匹配的情况，提高效率
//
//原理分析
// BM引入两个规则
// 
// 坏字符规则：
// BM也是从头开始，一次比较模式串与子串，单次比较中，不同点在于
// 每个字符倒着进行比较
// [ abc ] acabdc
// [ abd ]
// <-----
// 发现某个字符（这里是c）无法匹配，则定义c为坏字符
// 接着用坏字符在模式串中查找，不存在则直接移动模式串长度，继续比较
// abc [ aca ] bdc
//     [ abd ]
//     <-----
// 发现a无法匹配，定义为坏字符，但此时a在模式串abd中存在
// 则移动长度 = 模式串长度 - 坏字符在模式串位置 ，让坏字符与在模式串中存在的位置对齐
// 此例中移动两位
// abcac [ abd ] c
//		 [ abd ]
// 规律，将坏字符对应模式串中的字符下标记为si
// abc
// abd
//   👆 d位置记为si = 2
// 坏字符在模式串中存在的位置下标记为xi
// abc					aca
// abd					abd
// 不存在记为xi = -1	👆存在a的位置xi = 0
// 则一次性移动的距离为 si - xi
// 另外，如果坏字符在模式串中多次出现，计算xi应选择靠后的，因为子串是从后往前对比的
// baab
// aab
//   👆 si = 2, xi = 1 ,移动1位，如果记靠前的，移动2位，本来可能匹配的情况被略过
// 坏字符规则能够避免很多无意义比较
// 例如 aaabaaab匹配aaaa，每次si = 3，xi = -1，移动4位，效率很高
// 但也存在无法处理的情况
// 例如 aaaa匹配baaa，坏字符为第一个a，si = 0，而xi = 3，出现负数，难道需要倒退比较？
// 所以仅仅一条规则不够
// 
// 好后缀规则：
// 例如，两字符串匹配到如下位置
// abcacabcbcbacabc		abc [ acabcbc ] bacabc
// abbcabc ->				  abbcabc
// 后两个字符匹配，倒数第三个开始不匹配
// 把已经匹配的{bc}称为好后缀，记为{u}，那么在模式串中查找，看是否还有另一个{u}，记为{u*}
// 如果有，则将模式串滑动到子串{u*}与主串{u}对齐的位置
// abcaca [ bcbcbac ] abc
//          abbcabc
//			  👆
// 若没有另一个{u}，借助坏字符思想，看是否能直接把模式串移动到主串{u}之后的位置继续比较
// 例
// abc [ acabcbc ] bacabc										abcacabcbc [ bacabc
//		 cbacabc 好后缀{bc}在模式串中没有重复，直接滑动为-》				 cbacabc
// 可见，刚好错过了正确的匹配情况
// 规则需要完善
// 如果模式串前缀（去掉好后缀的部分），与主串{u}有部分重合时
// 应该考察好后缀子串，是否存在根模式串前缀子串匹配的
// 如上例 好后缀{bc}存在两个子串{b}{c}，{c}刚好匹配模式串第一个{c}
// 则滑动到匹配的位置，刚好完全匹配
// abcacabcb [ cbacabc 
//			   cbacabc
//			   👆
// 但在这种串匹配中，其实坏字符也是能够起作用的
// 在每一次的对比中，如何衡量使用哪种规则？
// 
// 答案
// 分别计算坏字符和好后缀向后移动的位数，取更大的一个
// 避免了坏字符的负数情况，也进一步提高滑动的速度
// 
//代码实现
// 坏字符较简单，si是逐字对比时得到，xi查找坏字符在模式串出现位置
// xi如果使用遍历查找，相对效率并不高，可以将模式串每个字符和下标存到散列表
// 字符集不大的情况，例如ascii码表，直接用256大小的数组，记录每个字符可匹配位置
constexpr int ASCII_SIZE = 256;
int bc[ASCII_SIZE] = { -1 };
void generateBC(char* b, size_t m)
{
	//初始化辅助散列表
	for (int i = 0; i < ASCII_SIZE; ++i)
		bc[i] = -1;//没找到的都记-1
	//遍历模式串，将每个字符所在位置存入辅助表
	for (int i = 0; i < m; ++i)
		bc[b[i]] = i;
	//例如abda，a的ascii为97，则bc[97] = 0
	//之后如果出现重复，覆盖前面值 bc[97] = 3，刚好符合多个匹配时选后者的规则
}
int bm(char* a, size_t n,/* 前面主串，后面模式串 */ char* b, size_t m)
{
	//仅考虑坏字符规则的实现
	generateBC(b, m);//提前计算好每个字符出现的位置，后面匹配时直接取就可以了
	int i = 0;//对齐位置，也就是主串和模式串对齐的第一个字符
	while (i <= n - m)//最多可向后滑动的距离
	{
		int j;
		//从后向前匹配
		for (j = m - 1; j >= 0; --j)
			if (a[i + j] != b[j])
				break;//不匹配，break后j为坏字符对应模式串中的下标，也就是si
		if (j < 0)
			return i;//坏字符匹配后j为-1，则说明完全匹配，返回匹配位置
		i += j - bc[a[i + j]];//从辅助表中，取出坏字符在模式串中匹配的最后位置，也就是xi，计算移动值i = si - xi
	}
	//每匹配则返回-1
	return -1;
}
// 好后缀同样，除了暴力匹配，也可以进行优化
// 也是预先处理好模式串的后缀子串，计算好每个子串的可匹配位置
// 例如 对于模式串 cabcab 
// 引入一个记录数组，下标对应子串长度，值表示模式串中跟好后缀{u}匹配的子串起始下标（多个匹配同样取靠后的一个）
// 引入一个标记数组，标记后缀子串是否匹配前缀子串
// 后缀子串		长度	记录数组									 标记数组
// b			1		suffix[1] = 2 匹配到相同后缀在2开始的位置	 prefix[1] = false
// ab			2		suffix[2] = 1								 prefix[2] = false
// cab			3		suffix[3] = 0								 prefix[3] = true
// bcab			4		suffix[4] = -1未匹配到记为-1				 prefix[4] = false
// abcab		5		suffix[5] = -1								 prefix[5] = false
// 计算方式
void generateGS(char* b, size_t m, int* suffix, bool* prefix)
{
	//初始化两个辅助数组
	for (int i = 0; i < m; ++i)
	{
		suffix[i] = -1;
		prefix[i] = false;
	}
	for (int i = 0; i < m - 1; ++i)
	{
		int j = i;
		int k = 0;//公共后缀子串长度
		while (j >= 0 && b[j] == b[m - 1 - k])
		{
			--j; ++k;
			suffix[k] = j + i;
		}
		if (j == -1) prefix[k] = true;
	}
}
int moveByGS(int j/* 坏字符对应模式串的下标，用于好后缀处理 */, int m, int* suffix, bool* prefix)
{
	//计算好后缀情况的位移
	int k = m - 1 - j;
	if (suffix[k] != -1)
		return j - suffix[k] + 1;
	for (int r = j + 2; r <= m - 1; ++r)//j未坏字符下标，j+1为好后缀第一个字符，+2为第二个
		if (prefix[m - r] == true)
			return r;
	return m;
}
#define max(a,b) (((a) > (b)) ? (a) : (b))
int bm2(char* a, size_t n, char* b, size_t m)
{
	//初始化这些辅助数组
	generateBC(b, m);
	int* suffix = new int[m];
	bool* prefix = new bool[m];
	generateGS(b, m, suffix, prefix);
	//记录匹配的第一个字符位置
	int i = 0;
	while (i <= n - m)
	{
		int j;
		for (j = m - 1; j >= 0; --j)
			if (a[i + j] != b[j])
				break;
		if (j < 0)
			return i;//直接匹配成功
		//坏字符位移计算
		int x = j - bc[a[i + j]];
		int y = 0;//记录好后缀方式位移
		if (j < m - 1)//存在好后缀
			y = moveByGS(j, m, suffix, prefix);
		//以两个方式计算的偏移量较大的为准
		i += max(x, y);
	}
	return -1;
}
// 由于使用了三个额外的辅助数组
// 当处理大字符串匹配，内存消耗较多
// 可以选择性只是用好后缀规则，但效率相对会降低

// 
//KMP算法
// BM是最搞笑的字符串匹配算法
// KMP核心思想相近，较出名
// 使用坏字符和好前缀的规则
// 遇到坏字符时，模式串向后滑动，在滑动过程中，看模式串和好前缀是否有重合
// 相当于是好前缀的后缀子串与模式串的前缀子串比较
// 把最长的可匹配前缀子串作为基准
// 也可以提前构建一个数组，存储模式串中每个前缀的最长可匹配前缀子串的结尾字符下标
// 这个数组的构建需要用到动态规划
// 一般称为next（失效函数）
//

//
//AC自动机
// 
//问题引入：敏感词过滤功能的实现
// 最基本的方式是字符串匹配，维护一个敏感词字典，一段文字通过匹配算法查找是否包含这些敏感词
// BF、RK、BM、KMP、和Trie（字典）树，都是单模式串，也就是一个模式串和一个主串匹配
// 如果是体量很大的项目，需要更高效的方式
//
//多模式串匹配算法
// 就是在多个模式串和一个主串之间匹配
// 经典多模式串匹配——AC自动机
// 
//核心思想
// 实际上是Trie树基础之上，加入了类似KMP的next辅助数组
class AcNode {
public:
	char data;//存放的字符
	AcNode* children[26];//假设字符集只含a-z
	bool isEndingChar = false;//是否是结尾字符
	AcNode* fail;//失败指针，相当于KMP的失效函数next数组
};
/*
例 主串abcd 模式串c、bc、bcd、abcd
构建字典树
		\0
	↗	↑ ↖
	a	b	c
	b↗ c↗
	c↗	d -》root
	d↗
每个节点都有一个失败指针（箭头）
*/
// 匹配方式
// 主串从i=0开始，AC自动机从p=root开始
// p指向系欸但有一个等于b[i]的子节点x，更新p指向x，并检查一系列失败指针为结尾的路径是否是模式串
// 之后i+1继续这两个过程
// 如果p指向的节点没有等于b[i]的子节点，那么让p=p->fail，继续处理这两个过程
/*
java
public void match(char[] text) { // text是主串
  int n = text.length;
  AcNode p = root;
  for (int i = 0; i < n; ++i) {
	int idx = text[i] - 'a';
	while (p.children[idx] == null && p != root) {
	  p = p.fail; // 失败指针发挥作用的地方
	}
	p = p.children[idx];
	if (p == null) p = root; // 如果没有匹配的，从root开始重新匹配
	AcNode tmp = p;
	while (tmp != root) { // 打印出可以匹配的模式串
	  if (tmp.isEndingChar == true) {
		int pos = i-tmp.length+1;
		System.out.println("匹配起始下标" + pos + "; 长度" + tmp.length);
	  }
	  tmp = tmp.fail;
	}
  }
}
*/
// 
//



//
//哈希算法
// 
//问题引入：数据库用户信息加密
// MD5或SHA加密密码
// 
//定义
// 将任意长度二进制值串映射为固定长度二进制值串
//
//要求
// 哈希值不能反向推导出原始数据
// 对输入数据非常敏感，哪怕只修改了一个bit，最后得到的哈希值也大不相同
// 散列冲突概率要非常小，对于不同的原始数据，哈希值相同的概率要非常小
// 哈希算法的执行效率要尽量高效，针对较长文本也能尽快算出结果
// 
//应用
// 加密 MD5、SHA、DES、AES
// 唯一标识 哈希+一些其他标记参数作为文件的唯一标识
// 数据校验 p2p协议，文件分块，每一块分别取哈希，某一块哈希值不能与原文件对应时，说明可能被修改
// 散列函数 散列表使用
// 
// 分布式系统中
// 负载均衡 
//  通常有轮询、随机等方式
//	也可以用哈希算法，计算IP值或会话ID的哈希值，再与服务器列表大小取模
//	好处是，同一个IP可以一直连到同一个后端服务器，对请求需要上下文关系的情况比较有用
// 数据分片
//	大量数据分析时，如1T日志文件，记录用户搜索关键词，快速统计搜索次数
//	可以依次读取每个数据，通过哈希计算，跟机器数取模，分配到对应的机器编号
//	哈希值相同的数据就会被分配到同一个机器上，接着分别在各机器上计算每个词的数量，再合并各机器结果
// 分布式存储
//	海量数据存储后，为了提高读取、写入能力，一般需要缓存
//	数据量过大时，分配在多台机器上，跟之前说的差不多，可以通过对机器数取模
//	但存在问题，当增加机器时，由于哈希计算涉及到机器数，那么每个数据的存放位置，全都要重新用新的值计算一遍
//	这个过程中相当于缓存全部失效，效率很低，需要等到所有数据重新放好
//	或者机器出问题，减少机器数，也是一样的情况
// 为了解决分布式系统中的增减机器情况，需要一种改良方案
// 
//一致性哈希
// 假设k个机器，哈希值范围[0,MAX]，那么把范围划分为m个区间（m>k)
// 每台机器负责m/k个小区间，画成圆或者直线看模型
// 0-+--+--|---+---+--+--|---+--+---+--+--|--+--+--+---+-+--|---+--+--+---+-|---+---+--+---MAX
// 	m1 m2  k1 m3...		k2 ...												kn mn
// 存储时，每条数据哈希值落在某个区间时，往后找到第一个机器，例如哈希为0~m1，放入k1
// 这种情况下，新增或删除机器时，大部分数据都不需要重新计算，只有小范围数据（新增机器到上一台机器之间的数据）重新计算即可
//



//
//红黑树
// 
//背景
// 二叉查找树，再极端情况下，树的高度一直朝着一个方向增长，可能几乎退化成链表
// 复杂度从O(logn)到O(n)
// 
//平衡二叉树
// 严格定义上，平衡的标准是：二叉树任意节点左右子树高度相差不能大于1
// 而实际中，平衡其实只需要整棵树看起来比较对称即可，不要出现一边倒，没必要严格死扣定义
// 这样，树的高度就比较均匀，插入、删除、查找等操作也效率高一些
// 
//红黑树定义
// 并不严格的平衡二叉树
// 在理解红黑树之前，需要看一种2-3树，是左倾红黑树的演变由来
// （完整红黑树应该是2-3-4树演变的，但作为原理，了解2-3树也够了）
// 不然上来就是一大堆特定规则，插入、删除、旋转，完全是死记硬背
// 
//2-3树
// 是二叉搜索树的变种
// 包含两种节点
// 2节点是普通节点，即一个元素，两条连接子节点
// 3节点是扩充节点，即两个元素，三条连接子节点
// 假如一个3节点包含AB两元素，则左连接节点值小于A，右连接节点值大于B，中间连接节点介于AB之间
//	   [5]					 [  5	10  ]
//	3		6				3	  7		12
// 两种节点配合，可以保证插入过程中，任意叶子节点到根节点距离都相同
// 
// 插入过程
// 将值插入2节点时，是将2节点扩充为3节点
//	   [5]				[ 5 6 ]		  或		[5]
//  3		7	插入  3			7			 3		[7 8]
// 将值插入3节点时
//	没有父节点，也就是整棵树目前只有一个3节点，则插入扩充为4节点并分解为一个二叉树
//	{ 5 10 ]	插入 13 ->		[ 5 10 13 ]  ->分解  10
//													5  13
//	有父节点且为父节点为2节点，则插入值后扩充为4节点并分解，分解后的父节点融到上面2节点里
//		3						3						3					[ 3   10 ]
//		  [ 5 10 ] 插入 		  [ 5 10 13 ]  分解		   10		融合	    5		13
//														5	  13
//	有父节点且父节点为3节点，则插入值为4节点并分解，分解后新父节点向上融合，3节点变4节点，分解、融合...直到遇到一个父节点为2节点的情况，转入上面的逻辑
//	例 7,8,9,10,11,12,13建立2-3树
//		[8]		|	[8]			|	   [8]			 |	  [8 10]	  |	  [8 10]			|  [8 10]	   |  [8 10 12]		 |		[10]
//	  7		9	| 7   [9 10]	|  7		10		 | 7	9     11  | 7	9	[11 12 13]	| 7	 9   12	   | 7	9	[11 13]	 |	  8		 12
//				|				|	    9	    11	 |				  |						|	   11  13  |				 |  7	9  11  13
// 
// 设计上，2-3树的扩充、分解、融合，保证了每一步之后，高度都是很均衡的
// 但代码并不容易实现，需要维护多种不同类型的节点，扩容、分解、融合又需要节点类型相互转换，需要处理的情况太多
// 所以才出现了红黑树
// 
//从 2-3树 到 红黑树 的演变
// 对于2节点，和普通节点一样，不需要处理
// 对于3节点，把节点拆开，原本在一起的两个值以一条标红的边连接，表示一种类似0高度的概念
//		 [a   b]					   b	（b大于a，所以b在上，因为2-3树中红连接只有左连接，2-3-4树中存在右红连接）
//		/   |   \		==》  [红] /	  \	
//	  <a  (a,b)  >b				  a		   \
// 							  <a   (a,b)	>b
// 红连接可视为不增加高度，所以三个叶子节点到根节点b的距离依然都是相同的，实现“黑色”平衡
// 将红连接放平，则是演变回2-3树
// 而边在代码中不是实际存在的，所以将红连接的节点标记为红色节点，就变成了红黑树
// 
//红黑树的基本要求
// 节点被颜色属性分为两类，一类为红色，一类为黑色															   | [a b c]					c
// 根节点为黑色（根节点不可能是红连接下的节点，所以只能是黑）												   |	分解  b		而不是	   / 红
// 任何相邻节点（同一条路径上的节点）不能同时为红色（因为如果是两个红说明是由4节点分解而来，而不符合分解方式）>|	 红 /   \ 红		  b
// 每个节点到其可达叶子节点的所有路径都包含想呕吐那个数量的黑节点（红节点0距离）							   |	  a		  c		    / 红
// 每个叶子节点都是黑色空节点，不存储数据（简化代码实现，辅助用）											   |					   a
// 
//近似平衡
// 平衡本身为了解决二叉搜索树动态更新导致的性能退化问题
// 近似平衡就是性能不会退化的很严重
// AVL树高度平衡，查找速度最高，但代价是，每次插入删除都要调整
// 红黑树的近似平衡，维护平衡的成本更低，查询效率也不会低很多
// 
//红黑树实现
// 类似魔方复原，遇到什么样的节点排布，就用一个对应的固定规则操作
// 在插入或删除时，红黑树的基本要求可能会被破坏，需要调整
// 两种基本操作
// 左旋		X		绕X旋		   Y		右旋	绕Y旋回来 	   X
//		  /	  \					 /   \						     /	 \
// 		a	   Y				X	  r						   a	   Y
// 			 /   \			  /   \							  		 /   \
// 		     b	  r			 a	   b						        b	  r
// 
// 插入操作的平衡调整
// 
// 规定
// 插入节点一定是红色，且放在叶子节点上
// 
// 两种特殊情况
// 插入节点的父节点是黑色，什么都不需要做，满足定义
// 插入节点为根节点，改为黑色即可
// 
// 其他情况（插入节点父节点为红）打破定义
// 调整
// 将正在处理的节点称为关注节点，最开始关注节点就是新插入节点
// 把父节点的兄弟节点叫叔节点，父节点的父节点为祖父节点
// 
// CASE 1：关注节点a，叔叔节点d为红色				 |		  c黑				c红		 |
//	将关注节点a的父节点b和叔节点d设置为黑			 |		/     \			  /     \	 | 类比2-3-4					  c
//	将关注节点a祖父节点c设置为红					 |	  b红	  d红		b黑		d黑  |		[b c d] 拆分，插入a		/   \
//	关注点变为a的祖父节点c							 |		\				   \		 |							 [b	a]	  d
//	继续考察										 |		 a红				a红		 |
// 
// CASE 2：叔节点d为黑色，a是其父节点b的右子节点	 |		  c黑			    c黑		 |
//	关注节点a变为父节点b							 |		/	  \			   /	\	 | 类比2-3-4
//	绕新关注点b左旋									 |	  b红	  d黑	    a红	    d黑	 |		[b c]	插入a		  [b a c]  （CASE2处理完不标准）
//  跳 CASE 3 继续处理								 |		 \				/			 |			\						\
//													 |		 a红		  b红			 |			 d						 d
// 																						 
// CASE 3：叔节点d为黑色，a是其父节点b的左子节点	 |		  c黑			b黑			 |
//	围绕关注节点a的祖父节点c右旋					 |		/     \		  /	    \		 | 类比2-3-4
//	交换父节点b和兄弟节点c（原祖父节点）颜色		 |	  b红     d黑	a红		c红		 |	   [a b c]	   实际上2，3合起来就相当于往 [b c] 插入了a
//	调整结束										 |	  /						   \	 |			\									  \
// 													 |	a红						   d黑	 |			  d										d
// 
// 删除操作的平衡调整
// 
// 针对删除节点初步调整
//  保证删除后仍满足每个节点到其可达叶子节点所有路径都包含相同的黑色节点
//  有些节点可能回标记为 红-黑 或 黑-黑 （红|黑对半是两种颜色都可能，红-黑和黑-黑都表示加了黑，也就是加了距离）
// 
// CASE 1：删除节点a，只有一个子节点b							    |						  |
//	此情况下，b一定是红色，a一定是黑色，其他情况不符合红黑树规定	|	  a黑		   b黑	  | 类比2-3-4
//	将a删除，把b替换到a位置，并改为黑色（也可以看作交换值并删除b）  |		 \				  |		  [a b] 删除a  [b]
//	调整结束，不需要二次调整										|		  b红			  |
// 
// CASE 2：删除节点a，有两个非空子节点，且后继节点就是右子节点c	    |	  a红|黑			   c红|黑
//	此情况，c一定没有左子树，删除a后，将c替换到a位置				|	   /    \			   /      \
//	把c颜色设置为跟a一样（若c本来是黑，可能会少一个黑）				|	b红|黑   c黑		 b红|黑   d红|黑+黑
//	所以将c的右子节点d加一个黑										|			  \
//  关注节点变成d，等待第二步调整									|			d红|黑
// 
// CASE 3：删除节点a，两个非空子节点，且后继节点不是右子节点c	    |	   a红|黑				   d红|黑
//	找到后继节点d													|	  /		 \				  /		\
//	与a交换并删除													|  b红|黑   c红|黑		  b红|黑	c红|黑+黑
//	将d设置成与a一样的颜色（若d本来是黑，会少一个黑）				|		   /					    /
//	所以将右子节点c加一个黑										    |		  d黑					e红|黑
//	关注节点变成c，等待第二步调整									|			\
// 																	|			e红|黑
// 
// 针对关注节点进行二次调整
//  经过初步调整，关注节点变成 红-黑 或 黑-黑
//	二次调整是为了让红黑树中不存在相邻红色节点
// 
// CASE 1：关注节点a，兄弟节点是红									|			b黑						c黑
//	围绕关注节点a的父节点b左旋										|		  /		\				  /		\
//	父节点b与祖父节点c交换颜色										| a红|黑+黑		c红			     b红	e黑
//	关注点不变														|			   /   \		   /	\
//	继续调整														|			 d黑   e黑	  a红|黑+黑  d黑
// 
// CASE 2：兄弟节点黑，并且c的子节点de都是黑						|		   b红|黑					b红|黑+黑
//	兄弟节点c颜色变红												|		  /		 \					/		\
//	关注节点a减一个黑												| a红|黑+黑		  c黑		   a红|黑		 c红
//	给父节点b加一个黑												|				 /	 \						/   \
//	关注点从a变为父节点b											|				d黑	 e黑				  d黑	e黑
//	继续调整														|
// 
// CASE 3：兄弟节点c黑，且c左子节点d是红，右子节点e是黑			    |		   b红|黑				   b红|黑
//	绕兄弟节点c右旋												    |		  /		 \				  /		\
//	节点c和d交换颜色												| a红|黑+黑		  c黑		a红|黑+黑	 d黑
//	关注点不变													    |				 /	 \					   \
//	跳 CASE 4													    |				d红	 e黑					c红 - e黑
// 
// CASE 4：兄弟节点c黑，右子节点e是红色							    |		   b红|黑					c红|黑
//	围绕关注节点a的父节点b左旋										|		  /		 \					/	 \
//	将c设置成b一样的颜色											| a红|黑+黑		  c黑			  b黑	 e黑
//	把b颜色设置为黑													|				 /	 \			 /	 \
//	关注点a减一个黑													|			d红|黑	 e红	a红|黑	d红|黑
//	节点e设置为黑													|
// 
//总结
// 比较难😛
//


//高级篇

//
//概率统计
//

//
//向量空间
//

//
//索引
//

//
//并行算法
//

int main()
{
	std::cout << "Hello World!\n";
}
